extends c

##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
snippet binc
	#include <boost/${1:shared_ptr}.hpp>
snippet ginc
	#include <glm/${1:vec3}.hpp>
snippet cinc
	#include <cth/${1:engine}.h>
snippet yinc
	#include <yaml-cpp/yaml.h>
snippet linc
	#include <lua.hpp>
snippet sinc
	#include <SDL2/${1:SDL2/SDL}.h>
snippet glew
	#include <GL/glew.h>

##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
# std::string
snippet str
	std::string

# std::unique_ptr
snippet uniq
	std::unique_ptr<${1:T}> ${2:ptr};
# make unique_ptr
snippet mkuniq
	auto ${1:ptr} = std::make_unique<${2:T}>(${3});
# std::shared_ptr
snippet share
	std::shared_ptr<${1:T}> ${2:ptr};
# make shared_ptr
snippet mkshare
	auto ${1:ptr} = std::make_shared<${2:T}>(${3});

##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
snippet cl
	class ${1:`vim_snippets#Filename('$1', 'name')`} {
	public:
		$1(${2});
		virtual ~$1();

	protected:
		${5};
	};

#class with descriptive comment
snippet clc
	/*! \class $1
	 *  \brief ${3:Brief class description}
	 * 
	 *  ${4:Detailed description} 	
	 */
	class ${1:`vim_snippets#Filename('$1', 'name')`} {
	public:
		$1(${2});
		virtual ~$1();

	protected:
		${5};
	};

# member function implementation
snippet mfun
	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0
	/*! \brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 * 
	 * \return ${6:Return parameter description}
	 */
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	/*! \brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 * 
	 * \param $4 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	/*! \brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 * 
	 * \param $4 ${10:Parameter description}
	 * \param $6 ${11:Parameter description}
	 * \return ${12:Return parameter description}
	 */
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
#func pointer definition
snippet funptr
	${1:void} (*${2:name})(${3:arg_types});
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`}
	{
		${0}
	} /* namespace $1 */
# annonymous namespace
snippet ans
	namespace {
		${0}
	}
##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cerr
snippet cerr
	std::cerr << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
# std::cout args passed to main
snippet cout_args
	for(int x = 0; x < argc; ++x) {
		std::cout << argv[x] << std::endl;
	}
snippet cerr_args
	for(int x = 0; x < argc; ++x) {
		std::cerr << argv[x] << std::endl;
	}
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori
	for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# for i with unsigned int
snippet forui
	for(unsigned int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for(${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for(${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for(auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};
# snippets exception 
snippet try
	try {
		
	} catch(${1}) {
		
	}
#string map selector
snippet map_sel
	enum ${1:enum_name} {
		${2:FIRST}
	};
	const std::map<std::string, $1> selector {
		{ "$2", $2 }
	};

	auto it = selector.find(${3:str});
	if(it != selector.end()) {
		switch(it->second) {
		case $2:
			break;
		}
	}
#useful opengl
snippet nvarray
	glGenVertexArrays(${1:1}, &${2:vao});
	glBindVertexArray($2);
snippet nibo
	glGenBuffers(${1:1}, &${2:ibo});
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, $2);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint) * ${3:indices}.size(), &$3[0], GL_STATIC_DRAW);
snippet nvbo
	glGenBuffers(${1:1}, &${2:vbo});
	glBindBuffer(GL_ARRAY_BUFFER, $2);
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec3) * ${3:vertices}.size(), &$3[0], GL_STATIC_DRAW);
snippet ntbo
	glGenBuffers(${1:1}, &${2:uvbo});
	glBindBuffer(GL_ARRAY_BUFFER, $2);
	glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * ${3:uvs}.size(), &$3[0], GL_STATIC_DRAW);
snippet enable_vaa
	glEnableVertexAttribArray(${1:0});
	glVertexAttribPointer($1, ${2:3}, GL_FLOAT, GL_FALSE, 0, 0);
#textures
snippet new_texture
	glBindTexture(GL_TEXTURE_2D, tid);
	glTexImage2D(GL_TEXTURE_2D, 0, GL)
snippet texture_filter
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ${1:GL_NEAREST});
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, $1);
snippet texture_filter_nearest
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
snippet texture_filter_linear
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
#blending
snippet enable_blend
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
#clear screen
snippet clear
	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
#drawing
snippet drawa
	glDrawArrays(${1:GL_TRIANGLES}, ${2:0}, ${3:480});
snippet drawe
	glDrawElements(${1:GL_TRIANGLE_STRIP}, ${2:indicies.size()}, GL_UNSIGNED_INT, 0);
snippet draw_rect
	glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, 0);
#useful lua stuff
#push values to lua
snippet luabool
	lua_pushboolean(l, ${1:true});
snippet luanum
	lua_pushnumber(l, ${1:0});
snippet luanil
	lua_pushnil(l);
snippet luaval
	lua_pushvalue(l, ${1:0});
snippet luastr
	lua_pushstring(l, ${1:str});
snippet luaint
	lua_pushinteger(l, ${1:0});
#get values from lua
snippet getluabool
	lua_toboolean(l, ${1:1});
snippet getluanum
	lua_tonumber(l, ${1:1});
snippet getluaint
	lua_tointeger(l, ${1:1});
snippet getluastr
	lua_tostring(l, ${1:1});
#create new lua function definition
snippet luafun
	int ${1:func}(lua_State* l);
snippet luafunv
	int ${1:func}(lua_State* l) {
		${2}
	}
snippet luacon
	${2:class_name}::$1(lua_State* l);
snippet luaconv
	${1:ns}::${2:class_name}::$2(lua_State* l) {
		$3
	}
#lua luna stuff
snippet luna
	/*
	 * name of the class that is to be registered with lua luna.
	 */
	static const char lua_class_name[];
	/*
	 * methods of the class that are to be registered with lua luna.
	 */
	static cth::luna<${1:lua_class}>::reg_type methods[];
	/*
	 * flag that states whether the object should be deleted by lua.
	 */
	bool lua_object = false;
snippet lunav
	const char ${1:class_name}::lua_class_name[] = "$1";
	#define method(class, name) {#name, &class::name}
	cth::luna<$1>::reg_type $1::methods[] = {
		method($1, ${2:func_ptr}),
		{ nullptr, nullptr }
	};
	#undef method
#create an engine state
snippet state
	class ${1:`vim_snippets#Filename('$1', 'name')`} : public cth::engine_state {
	public:
		$1();

	public:
		virtual void handle_event(SDL_Event& e) override;
		virtual void update() override;
		virtual void render() override;
	};
#implement the engine state virtual methods
snippet statev
	${1:`vim_snippets#Filename('$1', 'name')`}::$1(${2}) {

	}

	void $1::handle_event(SDL_Event& e) {
	
	}

	void $1::update() {
	
	}

	void $1::render() {
	
	}
#create new cth entity
snippet entity
	class ${1:new_entity} : public cth::entity {
	public:
		$1() {
		
		}
	};
#for each type of entity in entity manager
snippet fore_entity
	entities.for_each_t<${1:T}>([&]($1& ${2:ent}) {
		${3}
	});
#create new cth resource
snippet resource
	class ${1:new_resource} : public cth::resource {
	public:
		$1(const std::string& file);
		$1(lua_State* l) : cth::resource(l) { }

		/*
		 * method used by the resource manager to load resources from lua.
		 */
		static std::unique_ptr<cth::resource> lua_constructor(lua_State* l);
		/*
		 * static flag that is set to true when the resource has been registered against the resource manager class.
		 */
		static bool registered;
		/*
		 * name of the class that is to be registered with lua luna.
		 */
		static const char lua_class_name[];
		/*
		 * methods of the class that are to be registered with lua luna.
		 */
		static cth::luna<$1>::reg_type methods[];
	};
	
snippet resourcev
	${1:new_resouce}::$1(const std::string& file) {
	
	}

	std::unique_ptr<cth::resource> lua_constructor(lua_State* l) {
		std::string name = lua_tostring(l, 1);
		return std::make_unique<$1>(name);
	}

	bool $1::registered = false;
	const char $1::lua_class_name[] = "$1";
	#define method(class, name) {#name, &class::name}
	cth::luna<$1>::reg_type $1::methods[] = {
		method($1, ${2:func_ptr}),
		method($1, destroy),
		{ nullptr, nullptr }
	};
	#undef method

#boost program options
snippet bpo
	namespace {
		struct arg_values;
		bool process_args(int argc, const char* argv[], arg_values& output);

		struct arg_values {
			${1:std::string} ${2:test_arg};
		};

		bool process_args(int argc, const char* argv[], arg_values& output) {
			namespace po = boost::program_options;

			po::options_description desc("Allowed options");
			desc.add_options()
				("help", "produce help message")
				("${3:test_arg},${4:t}", po::value<$1>(), "${5:description}");

			po::variables_map vm;
			po::store(po::parse_command_line(argc, argv, desc), vm);

			if(vm.count("help")) {
				std::cerr << desc << "\n";
				return false;
			}

			if(vm.count("$3")) {
				output.$2 = vm["$3"].as<$1>();
				std::cerr << "$3 set to: " << output.$2 << ".\n";
			} else {
				std::cerr << "$3 was not set.\n";
				return false;
			}

			return true;
		}
	}
# qt stuff
#quickly define a new widget
snippet widgeth
	class ${1:widget_name} : public QWidget
	{
		Q_OBJECT

	public:
		explicit $1(QWidget* parent = NULL);
		~$1();

	public:
		void init();

	public slots:

	signals:

	};
#quickly define widget in cpp file
snippet widgetcpp
	${1:ns}::${2:widget_name}::$2(QWidget* parent) : QWidget(parent)
	{
		setObjectName("$2");
		init();
	}

	$1::$2::~$2()
	{
	
	}

	void $1::$2::init()
	{
	
	}
#quickly define a new page.
snippet pageh
	class ${1:pagename} : public Page
	{
		Q_OBJECT

	private:
		/*
		 * child widgets
		 */

	public:
		explicit $1(QWidget* parent = NULL);
		~$1();

	public:
		/*
		 * override function on page baseclass
		 */
		virtual void init();

		virtual QString getTitle() const;
		virtual std::vector<r2::buttons> getButtons() const;
	private:
		virtual MenuOptions getMenuOptions() const;

	public slots:
		/*
		 * override slot functions on page baseclass
		 * (delete as appropriate)
		 */
		virtual void onHomeButtonPressed();
		virtual void onLimitsButtonPressed();
		virtual void onLiftingButtonPressed();
		virtual void onRailButtonPressed();

		virtual void onMenuCommand(R2::MenuCommands command);
	};
snippet pagecpp
	R2::${1:pagename}::$1(QWidget* parent) : Page(parent) { }

	R2::$1::~$1() { }

	void R2::$1::init()
	{
	
	}

	QString R2::$1::getTitle() const
	{
		return "${2:Page Name}";
	}

	std::vector<R2::buttons> R2::$1::getButtons() const
	{
		std::vector<R2::buttons> bs;

		bs.push_back(R2::HOME_BUTTON);
		bs.push_back(R2::LIMITS_BUTTON);
		bs.push_back(R2::LIFTING_BUTTON);
		bs.push_back(R2::RAIL_BUTTON);
		bs.push_back(R2::MENU_BUTTON);

		return bs;
	}

	R2::MenuOptions R2::$1::getMenuOptions() const
	{
		MenuOptions options;
		
		/*
		 * push options here.
		 */

		return options;
	}

	void R2::$1::onHomeButtonPressed()
	{
	
	}

	void R2::$1::onLimitsButtonPressed()
	{
	
	}

	void R2::$1::onLiftingButtonPressed()
	{
	
	}

	void R2::$1::onRailButtonPressed()
	{
	
	}

	void R2::$1::onMenuCommand(R2::MenuCommands command)
	{
	
	}
#quickly define connection of signal and slot.
snippet connect
	QObject::connect(${1:emitter}, SIGNAL(${2:signal}(${3:type})),
			 ${4:receiver}, SLOT(${5:slot}($3)));
#Q_PROPERTY definition
snippet qprop
	/*!
	 * \brief Qt accessor for m$3
	 * \accessors get$3(), set$3()
	 */
	Q_PROPERTY(${1:type} ${2:name}
		   READ get${3:Name}
		   WRITE set$3)
#Q_PROPERTY definition with notify signal
snippet qpropn
	/*!
	 * \brief Qt accessor for m$3
	 * \accessors get$3(), set$3()
	 */
	Q_PROPERTY(${1:type} ${2:name}
		   READ get${3:Name}
		   WRITE set$3
		   NOTIFY $2Changed)

#Definition of getter in h file.
snippet gh
	/*!
	 * \brief Get the value of m$2
	 * \return The value of m$2
	 */
	${1:type} get${2:Value}() const;
snippet sh
	/*!
	 * \brief Set the value m$2
	 * \param val The new value of m$2
	 */
	void set$2($1 val);
#Definition of get setter in h file.
snippet gsh
	/*!
	 * \brief Get the value of m$2
	 * \return The value of m$2
	 */
	${1:type} get${2:Value}() const;
	/*!
	 * \brief Set the value m$2
	 * \param val The new value of m$2
	 */
	void set$2($1 val);
#Definition of getter in cpp file. (camel case)
snippet gcppcc
	/*
	 * Get the value of m$4
	 */
	${1:type} ${2:ns}::${3:class}::get${4:Value}() const
	{
		return m$4;
	}
#Definition of setter in cpp file. (camel case)
snippet scppcc
	/*
	 * Set the value of m$4
	 */
	void $2::$3::set$4($1 val)
	{
		m$4 = val;
	}
#Defintion of getter and setter in cpp file. (camel case)
snippet gscppcc
	/*
	 * Get the value of m$4
	 */
	${1:type} ${2:ns}::${3:class}::get${4:Value}() const
	{
		return m$4;
	}
	/*
	 * Set the value of m$4
	 */
	void $2::$3::set$4($1 val)
	{
		m$4 = val;
	}
#definition of getter in cpp file. (snake case)
snippet gcppsc
	/*
	 * Get the value of $4
	 */
	${1:type} ${2:ns}::${3:class}::get${4:Value}() const
	{
		return $4;
	}
snippet scppsc
	/*
	 * Set the value of $4
	 */
	void $2::$3::set$4($1 val)
	{
		$4 = val;
	}
#definition of getter and setter in cpp file. (snake case)
snippet gscppsc
	/*
	 * Get the value of $4
	 */
	${1:type} ${2:ns}::${3:class}::get${4:Value}() const
	{
		return $4;
	}
	/*
	 * Set the value of $4
	 */
	void $2::$3::set$4($1 val)
	{
		$4 = val;
	}
#Comment for r2 requirements
snippet r2req
	Fulfills requirements:
	* -#
	* <a href="https://confluence.prolec.info/display/R2/HCI#req-${1:HI-0001}">
	*    $1
	* </a>
snippet r2softreq
	Fulfills requirements:
	* -#
	* <a
	* href="https://confluence.prolec.info/display/R2/Software+Requirements#req-${1:SW-001}">
	*    $1
	* </a>
